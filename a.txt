#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include "time.h"
#include <SPI.h>
#include <SD.h>
#include <PubSubClient.h>

// Configuración de WiFi
const char* ssid = "wifi-ubb";
const char* password = "soporte-dci";

// Configuración NTP
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = -10800; // UTC-3 para Chile
const int daylightOffset_sec = 0;

// Configuración SD
const int chipSelect = 5;
const char* filePath = "/mediciones.txt";

// Configuración MQTT
const char* mqttServer = "broker.hivemq.com";
const int mqttPort = 1883;
WiFiClient espClient;
PubSubClient client(espClient);

// Estructura para almacenar horas de envío
struct HoraEnvio {
    int hora;
    int minuto;
};

const HoraEnvio horasEnvio[] = {
    {8, 0}, {12, 0}, {12, 30}, {14, 0}, {20, 0}
};

const int numHorasEnvio = sizeof(horasEnvio) / sizeof(horasEnvio[0]);

int ultimaHora = -1;
int ultimoMinuto = -1;

void setup() {
    Serial.begin(115200);
    WiFi.begin(ssid, password);

    while (WiFi.status() != WL_CONNECTED) {
        delay(1000);
        Serial.println("Conectando a WiFi...");
    }
    Serial.println("Conectado a WiFi!");

    // Configurar tiempo NTP
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
    Serial.println("Tiempo NTP configurado.");

    // Inicializar SD
    Serial.print("Iniciando tarjeta SD...");
    if (!SD.begin(chipSelect)) {
        Serial.println("Error al inicializar SD.");
        return;
    }
    Serial.println("Tarjeta SD lista.");

    // Configurar MQTT
    client.setServer(mqttServer, mqttPort);
}

void loop() {
    client.loop();
    registrarMedicion();  // Siempre guardar datos
    verificarEnvio();  // Verificar si es hora de enviar datos
    delay(2000);  // Cada 2 segundos para test
}

void registrarMedicion() {
    DynamicJsonDocument doc(256);
    doc["timestamp"] = obtenerHoraNTP();
    doc["temperatura"] = random(20, 30);
    doc["humedad"] = random(40, 60);
    doc["co2"] = random(300, 600);
    doc["ruido"] = random(50, 80);

    String jsonString;
    serializeJson(doc, jsonString);

    File dataFile = SD.open(filePath, FILE_APPEND);
    if (dataFile) {
        dataFile.println(jsonString);
        dataFile.close();
        Serial.println("Medición guardada en SD.");
    } else {
        Serial.println("Error al escribir en SD.");
    }
}

void verificarEnvio() {
    int horaActual, minutoActual;
    if (!obtenerHoraActual(horaActual, minutoActual)) return;

    for (int i = 0; i < numHorasEnvio; i++) {
        if (horaActual == horasEnvio[i].hora && minutoActual == horasEnvio[i].minuto) {
            if (horaActual != ultimaHora || minutoActual != ultimoMinuto) {
                enviarArchivoMQTT();
                ultimaHora = horaActual;
                ultimoMinuto = minutoActual;
            }
            break;
        }
    }
}

void enviarArchivoMQTT() {
    if (!client.connected()) {
        Serial.println("Conectando a MQTT...");
        if (client.connect("ESP32Client")) {
            Serial.println("Conectado a MQTT!");
        } else {
            Serial.print("Fallo MQTT, estado: ");
            Serial.println(client.state());
            return;  // Si no se conecta, no intentamos enviar
        }
    }

    File dataFile = SD.open(filePath);
    if (dataFile) {
        String payload;
        while (dataFile.available()) {
            payload += (char)dataFile.read();
        }
        dataFile.close();

        if (client.publish("esp32/mediciones", payload.c_str(), true)) {
            Serial.println("Archivo enviado a MQTT!");
            SD.remove(filePath);  // Solo borrar si el envío fue exitoso
        } else {
            Serial.println("Error enviando a MQTT. Se intentará más tarde.");
        }
    } else {
        Serial.println("No se encontró el archivo en SD.");
    }
}

bool obtenerHoraActual(int &hora, int &minuto) {
    struct tm timeinfo;
    if (!getLocalTime(&timeinfo)) {
        Serial.println("Error obteniendo la hora");
        return false;
    }
    hora = timeinfo.tm_hour;
    minuto = timeinfo.tm_min;
    return true;
}

String obtenerHoraNTP() {
    struct tm timeinfo;
    if (!getLocalTime(&timeinfo)) {
        Serial.println("Error obteniendo la hora");
        return "0000-00-00 00:00:00";
    }

    char buffer[20];
    snprintf(buffer, sizeof(buffer), "%04d-%02d-%02d %02d:%02d:%02d",
             timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday,
             timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);

    return String(buffer);
}
